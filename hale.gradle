import groovy.xml.XmlUtil

def getReleaseName() {
    if (os == 'linux') {
        return "hale-studio-${haleVersion}-linux.gtk.x86_64.tar"
    }
    if (os == 'windows') {
        return "hale-studio-${haleVersion}-win32.win32.x86_64.zip"
    }
    if (os == 'macos') {
        return "hale-studio-${haleVersion}-macosx.cocoa.x86_64.tar"
    }
    throw new IllegalArgumentException()
}

def getPackageName() {    
    def version = haleVersion

    version += "-ii-${new Date().format( 'yyyyMMdd' )}"

    if (os == 'linux') {
        return "hale-studio-${version}-linux.gtk.x86_64.tar.gz"
    }
    if (os == 'windows') {
        return "hale-studio-${version}-win32.win32.x86_64.zip"
    }
    if (os == 'macos') {
        return "hale-studio-${version}-macosx.cocoa.x86_64.tar"
    }
    throw new IllegalArgumentException()
}

def getDownloadUrl() {
    if (dev) {
        return "https://builds.wetransform.to/job/hale/job/hale~publish(master)/lastSuccessfulBuild/artifact/build/target/${getReleaseName()}"
    }

    return "https://github.com/halestudio/hale/releases/download/${haleVersion}/${getReleaseName()}"
}

task downloadHale(type: Download) {
    src getDownloadUrl()
    dest new File(new File(System.getProperty("java.io.tmpdir")), "${project.name}/${getReleaseName()}")
    overwrite false
}

task getHale(dependsOn: downloadHale, type: Copy) {
    from(os == 'windows' ? zipTree(downloadHale.dest) : tarTree(downloadHale.dest)) {
        include "hale*/**"
        eachFile { fcd ->
            fcd.relativePath = new RelativePath(true, fcd.relativePath.segments.drop(1))
            fcd.mode = 0755
        }
        includeEmptyDirs = false
    }
    into new File(buildDir, 'hale')
}

task cleanHale(dependsOn: getHale, type: Delete) {
    File cfgDir = getHale.destinationDir
    if (os == "macos") {
        cfgDir = new File(cfgDir, 'hale studio.app/Contents/Eclipse')
    }
    delete new File(cfgDir, 'features').listFiles().findAll {it.name.startsWith("de.interactive_instruments") || it.name.contains("xtraserver")}
    delete fileTree("${cfgDir}/plugins") {
        include 'de.interactive_instruments*'
        include '*.xtraserver*'
        include '*.ldproxy*'
    }
    doFirst {
        println (targetFiles.files)
    }
}

task pluginsHale(dependsOn: [cleanHale, bundleFeatures], type: Copy) {
    from(buildDir) {
        include 'plugins/*'
    }
    new File(buildDir, 'features').listFiles().each {file ->
        from(zipTree(file)) {
            eachFile { fcd ->
                fcd.relativePath = new RelativePath(true, (['features', file.name.take(file.name.lastIndexOf('.'))] + (fcd.relativePath.segments as List)) as String[])
            }
            includeEmptyDirs = false
        }
    }
    File cfgDir = getHale.destinationDir
    if (os == "macos") {
        cfgDir = new File(cfgDir, 'hale studio.app/Contents/Eclipse')
    }
    into cfgDir
}

task patchHale(dependsOn: pluginsHale) {
    doLast {
        File cfgDir = getHale.destinationDir
        if (os == "macos") {
            cfgDir = new File(cfgDir, 'hale studio.app/Contents/Eclipse')
        }

        // enable debugging
        new File(cfgDir, 'HALE.ini').append('-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005')

        // cleanup bundles.info
        def bundlesInfo = new File(cfgDir, 'configuration/org.eclipse.equinox.simpleconfigurator/bundles.info')
        def bundlesInfoFiltered = bundlesInfo.filterLine {!it.contains("xtraserver") && !it.contains("ldproxy")}
        bundlesInfo.write(bundlesInfoFiltered.toString(), 'UTF-8')



        // cleanup artifacts.xml
        def artifactsXml = new File(cfgDir, 'artifacts.xml')
        def repository = new XmlSlurper().parse(artifactsXml)

        // update time
        String current = "${new Date().getTime()}"
        repository.'properties'.'property'
                .find {it.'@name'.text() == 'p2.timestamp'}.'@value' = current

        // remove all xtraserver artifacts
        def sizeDiff = 0
        repository.artifacts.artifact
                .findAll { def x = it.'@id'.text().contains("xtraserver") || it.'@id'.text().contains("ldproxy"); if (x) sizeDiff--; return x  }
                .replaceNode {}

        // add plugins to bundles.info and artifacts.xml
        new File(buildDir, 'plugins').listFiles().each {file ->
            def id = file.name.take(file.name.lastIndexOf('_'))
            def rest = file.name.drop(file.name.lastIndexOf('_')+1)
            def version = rest.take(rest.lastIndexOf('.'))
            def size = file.size()
            println "$id $version"
            sizeDiff++

            bundlesInfo.append("${id},${version},plugins/${file.name},4,false\n")

            repository.artifacts.appendNode {
                artifact(classifier: 'osgi.bundle', id: id, version: version) {
                    'properties'(size: '1') {
                        'property'(name: 'download.size', value: "${size}")
                    }
                }
            }
        }

        // update platform.xml
        def platformXml = new File(cfgDir, 'configuration/org.eclipse.update/platform.xml')
        def config = new XmlSlurper().parse(platformXml)
        config.'@date' = current

        // add features to artifacts.xml and platform.xml
        new File(buildDir, 'features').listFiles().each {file ->
            def base = file.name.take(file.name.lastIndexOf('.'))
            def id = file.name.take(file.name.lastIndexOf('_'))
            def rest = file.name.drop(file.name.lastIndexOf('_')+1)
            def version = rest.take(rest.lastIndexOf('.'))
            def size = file.size()
            println "$id $version"
            sizeDiff++

            repository.artifacts.appendNode {
                artifact(classifier: 'org.eclipse.update.feature', id: id, version: version) {
                    'properties'(size: '1') {
                        'property'(name: 'download.size', value: "${size}")
                    }
                    'repositoryProperties'(size: '1') {
                        'property'(name: 'artifact.folder', value: 'true')
                    }
                }
            }

            config.site.appendNode {
                feature(id: id, version: version, url: "features/${base}/")
            }
        }

        // update number of artifacts
        if (sizeDiff != 0) {
            repository.artifacts.'@size' = String.valueOf(Integer.parseInt(repository.artifacts.'@size'.text()) + sizeDiff)
        }

        // write adjusted artifacts.xml and platform.xml
        artifactsXml.write(XmlUtil.serialize(repository), 'UTF-8')
        platformXml.write(XmlUtil.serialize(config), 'UTF-8')
    }
}

task hale(dependsOn: patchHale, type:Exec) {
    workingDir new File(buildDir, 'hale')
    if (os == 'windows') {
        commandLine 'cmd', '/c', 'HALE.exe'
    } else if (os == 'macos') {
        commandLine 'arch',  '-x86_64', './hale studio.app/Contents/MacOS/HALE'
    } else {
        commandLine './HALE'
    }
}

task packageHale(dependsOn: patchHale, type: os == "windows" ? Zip : Tar) {
    archiveFileName = getPackageName()
    destinationDirectory = file("$buildDir/dist")
    if (os != "windows")
        compression = Compression.GZIP

    from "$buildDir/hale"
    into getReleaseName() - (os == "windows" ? ".zip" : ".tar.gz")
}
